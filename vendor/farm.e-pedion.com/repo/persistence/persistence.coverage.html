
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">farm.e-pedion.com/repo/persistence/cassandra/cassandra.go (75.8%)</option>
				
				<option value="file1">farm.e-pedion.com/repo/persistence/cassandra/persistence.go (82.8%)</option>
				
				<option value="file2">farm.e-pedion.com/repo/persistence/persistence.go (90.3%)</option>
				
				<option value="file3">farm.e-pedion.com/repo/persistence/sql/persistence.go (80.8%)</option>
				
				<option value="file4">farm.e-pedion.com/repo/persistence/sql/sql.go (73.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cassandra

import (
        "errors"
        "farm.e-pedion.com/repo/logger"
        "farm.e-pedion.com/repo/persistence"
        "fmt"
        "github.com/gocql/gocql"
        "strings"
)

var (
        NotFoundErr        = gocql.ErrNotFound
        CassandraClientKey = "cassandra.Client"
        ClientNotFoundErr  = errors.New("cassandra.ClientNotFoundErr message='Cassandra client does not found at context'")
)

func NewDelegateSession(d *gocql.Session) Session <span class="cov8" title="1">{
        return &amp;DelegateSession{
                session: d,
        }
}</span></span>

type DelegateSession struct {
        session *gocql.Session
}

func (d *DelegateSession) Query(cql string, params ...interface{}) Query <span class="cov8" title="1">{
        cqlQuery := d.session.Query(cql, params...)
        return NewDelegateQuery(cqlQuery)
}</span></span>

func (d *DelegateSession) Closed() bool <span class="cov8" title="1">{
        return d.session.Closed()
}</span></span>

func (d *DelegateSession) Close() <span class="cov8" title="1">{
        d.session.Close()
}</span></span>

func NewDelegateQuery(d *gocql.Query) Query <span class="cov8" title="1">{
        return &amp;DelegateQuery{
                query: d,
        }
}</span></span>

type DelegateQuery struct {
        query *gocql.Query
}

func (d *DelegateQuery) Consistency(c gocql.Consistency) Query <span class="cov8" title="1">{
        d.query = d.query.Consistency(c)
        return d
}</span></span>

func (d *DelegateQuery) Exec() error <span class="cov8" title="1">{
        return d.query.Exec()
}</span></span>

func (d *DelegateQuery) Iter() Iter <span class="cov8" title="1">{
        cqlIter := d.query.Iter()
        return NewDelegateIter(cqlIter)
}</span></span>

func (d *DelegateQuery) PageSize(n int) Query <span class="cov8" title="1">{
        d.query = d.query.PageSize(n)
        return d
}</span></span>

func (d *DelegateQuery) Release() <span class="cov8" title="1">{
        d.query.Release()
}</span></span>

func (d *DelegateQuery) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        return d.query.Scan(dest...)
}</span></span>

func NewDelegateIter(d *gocql.Iter) Iter <span class="cov8" title="1">{
        return &amp;DelegateIter{
                iter: d,
        }
}</span></span>

type DelegateIter struct {
        iter *gocql.Iter
}

func (d *DelegateIter) Close() error <span class="cov8" title="1">{
        return d.iter.Close()
}</span></span>

func (d *DelegateIter) NumRows() int <span class="cov0" title="0">{
        return d.iter.NumRows()
}</span></span>

func (d *DelegateIter) Scanner() persistence.Iterable <span class="cov8" title="1">{
        return d.iter.Scanner()
}</span></span>

type sessionObject struct {
        //session is a transient pointer to database connection
        session Session
}

//SetSession attachs a database connection to Card
func (d *sessionObject) SetSession(session Session) error <span class="cov8" title="1">{
        if session == nil </span></span><span class="cov0" title="0">{
                return errors.New("NullSessionReferenceErr: Message='The db parameter is required'")
        }</span></span>
        <span class="cov8" title="1">d.session = session
        return nil</span></span>
}

//GetSession returns the Card attached connection
func (d sessionObject) GetSession() (Session, error) <span class="cov0" title="0">{
        if d.session == nil </span></span><span class="cov0" title="0">{
                return nil, errors.New("NotAttachedErr: Message='The cassandra session is null'")
        }</span></span>
        <span class="cov0" title="0">return d.session, nil</span></span>
}

func (d *sessionObject) Close() error <span class="cov8" title="1">{
        // return d.SetSession(nil)
        return nil
}</span></span>

//QuerySupport adds query capability to the struct
type QuerySupport struct {
        sessionObject
}

//QueryOne executes the single result cql query with the provided parameters and fetch the result
func (q *QuerySupport) QueryOne(query string, fetchFunc func(persistence.Fetchable) error, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span></span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='NilReadQuery")
        }</span></span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span></span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='EmptyReadParameters")
        }</span></span>
        <span class="cov8" title="1">if fetchFunc == nil </span></span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='NilFetchFunction")
        }</span></span>
        <span class="cov8" title="1">cqlQuery := q.session.Query(query, params...).Consistency(gocql.One)
        return fetchFunc(cqlQuery)</span></span>
}

//Query executes the cql query with the provided parameters and process the results
func (q *QuerySupport) Query(query string, iterFunc func(persistence.Iterable) error, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span></span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='EmptyCQLQuery']")
        }</span></span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span></span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='EmptyQueryParameters']")
        }</span></span>
        <span class="cov8" title="1">if iterFunc == nil </span></span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='NilIterFunc']")
        }</span></span>
        <span class="cov8" title="1">queryIter := q.session.Query(query, params...).Consistency(gocql.All).Iter()
        defer queryIter.Close()
        return iterFunc(queryIter.Scanner())</span></span>
}

//ExecSupport adds cql exec capability to the struct
type ExecSupport struct {
        sessionObject
}

//Exec exeutes the command with the provided parameters
func (i *ExecSupport) Exec(cql string, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(cql) == "" </span></span><span class="cov0" title="0">{
                return errors.New("ExecError[Messages='NilCQLQuery']")
        }</span></span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span></span><span class="cov0" title="0">{
                return errors.New("ExecParametersLenInvalid[Messages='EmptyExecParameters']")
        }</span></span>
        <span class="cov8" title="1">err := i.session.Query(cql, params...).Exec()
        if err != nil </span></span><span class="cov8" title="1">{
                logger.Error("CQLExecutionFalied",
                        logger.String("CQL", cql),
                        logger.Struct("Parameters", params),
                )
                return err
        }</span></span>
        <span class="cov8" title="1">logger.Debug("CQLExecutedSuccessfully",
                logger.String("CQL", cql),
                logger.Struct("Parameters", params),
        )
        return nil</span></span>
}

//NewClient creates a new instance of the CQLClient
func NewClient(session Session) *Client <span class="cov8" title="1">{
        client := new(Client)
        client.QuerySupport.SetSession(session)
        client.ExecSupport.SetSession(session)
        return client
}</span></span>

//CQLClient adds full query and exec support fot the struct
type Client struct {
        QuerySupport
        ExecSupport
}

func (c *Client) Close() error <span class="cov8" title="1">{
        var errs []error
        if err := c.QuerySupport.Close(); err != nil </span></span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span></span>
        <span class="cov8" title="1">if err := c.ExecSupport.Close(); err != nil </span></span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span></span>
        <span class="cov8" title="1">if len(errs) &gt; 0 </span></span><span class="cov0" title="0">{
                return fmt.Errorf("cassandra.Client.CloseErr msg='%v'", errs)
        }</span></span>
        <span class="cov8" title="1">return nil</span></span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cassandra

import (
        "errors"
        "farm.e-pedion.com/repo/logger"
        "farm.e-pedion.com/repo/persistence"
        "fmt"
        "github.com/gocql/gocql"

        // "github.com/matryer/resync"
        "time"
)

//pool is a variable to hold the Cassandra Pool
var (
        // once          resync.Once
        Config *Configuration
)

//Configuration holds Cassandra connections parameters
type Configuration struct {
        URL       string        `json:"url" mapstructure:"url"`
        Keyspace  string        `json:"keyspace" mapstructure:"keyspace"`
        Username  string        `json:"username" mapstructure:"username"`
        Password  string        `json:"password" mapstructure:"password"`
        NumConns  int           `json:"numConns" mapstructure:"numConns"`
        KeepAlive time.Duration `json:"keepAliveDuration" mapstructure:"keepAliveDuration"`
}

func (c Configuration) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("cassandra.Configuration URL=%v Keyspace=%v Username=%v Password=%v NumConns=%d KeepAlive=%s",
                c.URL, c.Keyspace, c.Username, c.Password, c.NumConns, c.KeepAlive,
        )
}</span></span>

//Session is the interface interact with the cassandra
type Session interface {
        Query(string, ...interface{}) Query
        Closed() bool
        Close()
}

//Query is an interface to execute cql commands
type Query interface {
        // func (q *Query) Bind(v ...interface{}) *Query
        Consistency(gocql.Consistency) Query
        Exec() error
        Iter() Iter
        PageSize(n int) Query
        Release()
        Scan(dest ...interface{}) error
        //String() string
        //WithContext(ctx context.Context) Query
}

//Iter is an interface to read data sets from cassandra
type Iter interface {
        Close() error
        NumRows() int
        Scanner() persistence.Iterable
}

//Setup configures a poll for database connections
func Setup(cfg *Configuration) error <span class="cov8" title="1">{
        logger.Info("cassandra.ConfigCluster",
                logger.String("configuration", cfg.String()),
        )
        cluster := gocql.NewCluster(cfg.URL)
        cluster.NumConns = cfg.NumConns
        cluster.SocketKeepalive = cfg.KeepAlive
        cluster.ProtoVersion = 4
        cluster.Keyspace = cfg.Keyspace
        cluster.Authenticator = gocql.PasswordAuthenticator{
                Username: cfg.Username,
                Password: cfg.Password,
        }

        session, err := cluster.CreateSession()
        if err != nil </span></span><span class="cov0" title="0">{
                return fmt.Errorf("cassandra.CreateSessionErr err=%v", err.Error())
        }</span></span>
        <span class="cov8" title="1">pool := &amp;Pool{
                cluster: cluster,
                session: NewDelegateSession(session),
        }
        if err = persistence.Setup(pool); err != nil </span></span><span class="cov0" title="0">{
                return fmt.Errorf("cassandra.SetupPersistenceErr err=%v", err.Error())
        }</span></span>
        <span class="cov8" title="1">logger.Info("cassandra.DriverConfigured",
                logger.String("config", cfg.String()),
        )
        Config = cfg
        return nil</span></span>
}

//Pool controls how new gocql.Session will create and maintained
type Pool struct {
        cluster *gocql.ClusterConfig
        session Session
}

func (c Pool) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("CassandraPool Configuration=%s ClusterIsNil=%t SessionIsNil=%t",
                Config.String(),
                c.cluster == nil,
                c.session == nil,
        )
}</span></span>

//Get creates and returns a Client reference
func (c *Pool) Get() (persistence.Client, error) <span class="cov8" title="1">{
        if c == nil || c.session == nil </span></span><span class="cov0" title="0">{
                return nil, errors.New("SetupMustCalled: Message='You must call Setup with a CassandraConfig before get a Cassandrapool reference')")
        }</span></span>
        <span class="cov8" title="1">if c.session.Closed() </span></span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cassandra.SessionIsClosedErr")
        }</span></span>
        <span class="cov8" title="1">logger.Debug("cassandra.GetSession",
                logger.String("Pool", c.String()),
                logger.Bool("SessionIsNil", c.session == nil),
                logger.Bool("SessionIsClosed", c.session.Closed()),
        )
        return NewClient(c.session), nil</span></span>
}

//Close close the database pool
func (c *Pool) Close() error <span class="cov8" title="1">{
        if c == nil || c.cluster == nil </span></span><span class="cov0" title="0">{
                return errors.New("SetupMustCalled: Message='You must call Setup with a CassandraBConfig before get a Cassandrapool reference')")
        }</span></span>
        <span class="cov8" title="1">logger.Info("CloseCassandraSession",
                logger.String("CassandraPool", c.String()),
        )
        c.session.Close()
        return nil</span></span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package persistence

import (
        "context"
        "errors"
        "fmt"
)

var (
        persistenceClientKey = 40
        ErrInvalidState      = errors.New("The persistence current state is invalid. Setup never called")
        ErrInvalidClientPool = errors.New("The provided ClientPool is invalid")
        ErrInvalidContext    = errors.New("The provided Context is invalid")
        ErrInvalidConfig     = errors.New("The provided Configuration is invalid")
        pool                 ClientPool
)

//Configuration holds Cassandra connections parameters
type Configuration struct {
        Provider string `json:"provider" mapstructure:"provider"`
}

func (c Configuration) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("persistence.Configuration Provider=%v", c.Provider)
}</span>

//Fetchable supply the gocql.Query.Scan interface for a struct
type Fetchable interface {
        Scan(dest ...interface{}) error
}

//Iterable supply the Iter interface for a struct
type Iterable interface {
        Fetchable
        Next() bool
}

//Reader provides the interface for persistence read actions
type Reader interface {
        QueryOne(query string, fetchFunc func(Fetchable) error, params ...interface{}) error
        Query(query string, iterFunc func(Iterable) error, params ...interface{}) error
        Close() error
}

//Executor provides cassandra exec supports
type Executor interface {
        Exec(command string, params ...interface{}) error
}

//ClientPool is a contrant for a persistence Client pool
type ClientPool interface {
        Get() (Client, error)
        Close() error
}

//Client adds full persistence supports
type Client interface {
        Reader
        Executor
}

//Readable provides read actions for a struct
type Readable interface {
        Reader
        Fetch(fetchable Fetchable) error
        // Iter(iterable Iterable) error
        Read() error
        //ReadExample() ([]Readable, error)
}

//Writable provides persistence actions for a struct
type Writable interface {
        Executor
        Create() error
        Update() error
        Delete() error
}

//Setup initializes the persistence package
func Setup(p ClientPool) error <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return ErrInvalidClientPool
        }</span>
        <span class="cov8" title="1">pool = p
        return nil</span>
}

//GetPool returns the pool instance
func GetPool() (ClientPool, error) <span class="cov8" title="1">{
        if pool == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidState
        }</span>
        <span class="cov8" title="1">return pool, nil</span>
}

//GetClient reads a dbClient from a context
func GetClient(c context.Context) (Client, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidContext
        }</span>
        <span class="cov8" title="1">client, ok := c.Value(persistenceClientKey).(Client)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("persistence.ErrInvalidClient client=%+v", client)
        }</span>
        <span class="cov8" title="1">return client, nil</span>
}

//SetClient preapres and set a persistence Client into context
func SetClient(c context.Context) (context.Context, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidContext
        }</span>
        <span class="cov8" title="1">persistenceClient, err := pool.Get()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return context.WithValue(c, persistenceClientKey, persistenceClient), nil</span>
}

//ContextFunc is a functions with context olny parameter
type ContextFunc func(context.Context) error

//ExecuteContext preapres a Client and set it inside context to call the provided function
func ExecuteContext(ctxFunc ContextFunc) error <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        ctx, err := SetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ctxFunc(ctx)</span>
}

//ClientFunc is a functions with context olny parameter
type ClientFunc func(Client) error

//Execute gets a Client from the ClientPool and calls the provided function with the Client instance
func Execute(cliFunc ClientFunc) error <span class="cov8" title="1">{
        persistenceClient, err := pool.Get()
        defer persistenceClient.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cliFunc(persistenceClient)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cassandra

import (
        "database/sql"
        "errors"
        "farm.e-pedion.com/repo/logger"
        "farm.e-pedion.com/repo/persistence"
        "fmt"

        "time"
)

var (
        Config *Configuration
)

//Configuration holds Cassandra connections parameters
type Configuration struct {
        Driver    string        `json:"driver" mapstructure:"driver"`
        URL       string        `json:"url" mapstructure:"url"`
        Database  string        `json:"database" mapstructure:"database"`
        Username  string        `json:"username" mapstructure:"username"`
        Password  string        `json:"password" mapstructure:"password"`
        NumConns  int           `json:"numConns" mapstructure:"numConns"`
        KeepAlive time.Duration `json:"keepAliveDuration" mapstructure:"keepAliveDuration"`
}

func (c Configuration) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("sql.Configuration Driver=%s URL=%s Database=%s Username=%s Password=%s NumConns=%d KeepAlive=%s",
                c.Driver, c.URL, c.Database, c.Username, c.Password, c.NumConns, c.KeepAlive,
        )
}</span>

type SqlDB interface {
        //func (db *DB) Begin() (*Tx, error)
        Close() error
        //func (db *DB) Driver() driver.Driver
        Exec(string, ...interface{}) (sql.Result, error)
        Ping() error
        //func (db *DB) Prepare(query string) (*Stmt, error)
        Query(string, ...interface{}) (Rows, error)
        QueryRow(string, ...interface{}) Row
        //func (db *DB) SetConnMaxLifetime(d time.Duration)
        //func (db *DB) SetMaxIdleConns(n int)
        //func (db *DB) SetMaxOpenConns(n int)
        //func (db *DB) Stats() DBStats
}

type Rows interface {
        persistence.Iterable
}

type Row interface {
        persistence.Fetchable
}

//Setup configures a poll for database connections
func Setup(cfg *Configuration) error <span class="cov8" title="1">{
        logger.Info("sql.ConfigDatasource",
                logger.String("configuration", cfg.String()),
        )
        datasource := &amp;Datasource{
                Driver:   cfg.Driver,
                Username: cfg.Username,
                Password: cfg.Password,
                URL:      cfg.URL,
        }
        db, err := sql.Open(datasource.Driver, datasource.DSN())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sql.OpenErr err=%v", err.Error())
        }</span>
        <span class="cov8" title="1">pool := &amp;Pool{
                datasource: datasource,
                db:         NewDelegateDB(db),
        }
        if err = persistence.Setup(pool); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sql.SetupPersistenceErr err=%v", err.Error())
        }</span>
        <span class="cov8" title="1">logger.Info("sql.DriverConfigured",
                logger.String("driver", cfg.URL),
                logger.String("url", cfg.Driver),
        )
        Config = cfg
        return nil</span>
}

//Pool controls how new sql.DB will create and maintained
type Pool struct {
        datasource *Datasource
        db         SqlDB
}

func (c Pool) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("sql.Pool Configuration=%s DatasourceIsNil=%t DBIsNil=%t",
                Config.String(),
                c.datasource == nil,
                c.db == nil,
        )
}</span>

//Get creates and returns a Client reference
func (c *Pool) Get() (persistence.Client, error) <span class="cov8" title="1">{
        if c == nil || c.db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetupMustCalled: Message='You must call Setup with a SqlConfig before get a SqlPool reference')")
        }</span>
        <span class="cov8" title="1">if err := c.db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Debug("sql.Get",
                logger.String("Pool", c.String()),
        )
        return NewClient(c.db), nil</span>
}

//Close close the database pool
func (c *Pool) Close() error <span class="cov8" title="1">{
        if c == nil || c.db == nil </span><span class="cov0" title="0">{
                return errors.New("SetupMustCalled: Message='You must call Setup with a SqlConfig before get a SqlPool reference')")
        }</span>
        <span class="cov8" title="1">logger.Info("sql.CloseDB",
                logger.String("DBPool", c.String()),
        )
        return c.db.Close()</span>
}

//Datasource holds parameterts to create new sql.DB connections
type Datasource struct {
        Driver   string
        URL      string
        Username string
        Password string
}

//DSN retuns a DSN representation of Datasource struct
//DSN format: [username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]
func (d *Datasource) DSN() string <span class="cov8" title="1">{
        //TODO: Fix this
        if d.Driver == "postgres" </span><span class="cov8" title="1">{
                return fmt.Sprintf("postgres://%s:%s@%s", d.Username, d.Password, d.URL)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s:%s@%s", d.Username, d.Password, d.URL)</span>

}

//FromDSN fills the connection parameters of this Datasource instance
// func (d *Datasource) FromDSN(DSN string) error {
//         regex := "(()?(:())@)?()?/()?"
//         return fmt.Errorf("NotImplemented: Regex='%v'", regex)
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">package cassandra

import (
        "database/sql"
        "errors"
        "farm.e-pedion.com/repo/logger"
        "farm.e-pedion.com/repo/persistence"
        "fmt"
        "strings"
)

var (
        NotFoundErr       = sql.ErrNoRows
        SqlClientKey      = "sql.Client"
        ClientNotFoundErr = errors.New("sql.ClientNotFoundErr message='Sql client does not found at context'")
)

func NewDelegateDB(d *sql.DB) SqlDB <span class="cov8" title="1">{
        return &amp;DelegateDB{
                db: d,
        }
}</span>

type DelegateDB struct {
        db *sql.DB
}

func (d *DelegateDB) Exec(sql string, params ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        return d.db.Exec(sql, params...)
}</span>

func (d *DelegateDB) QueryRow(sql string, params ...interface{}) Row <span class="cov8" title="1">{
        row := d.db.QueryRow(sql, params...)
        return NewDelegateRow(row)
}</span>

func (d *DelegateDB) Query(sql string, params ...interface{}) (Rows, error) <span class="cov8" title="1">{
        rows, err := d.db.Query(sql, params...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewDelegateRows(rows), nil</span>
}

func (d *DelegateDB) Ping() error <span class="cov8" title="1">{
        return d.db.Ping()
}</span>

func (d *DelegateDB) Close() error <span class="cov0" title="0">{
        return d.db.Close()
}</span>

func NewDelegateRow(row *sql.Row) Row <span class="cov8" title="1">{
        return &amp;DelegateRow{
                row: row,
        }
}</span>

type DelegateRow struct {
        row *sql.Row
}

func (d *DelegateRow) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        return d.row.Scan(dest...)
}</span>

func NewDelegateRows(rows *sql.Rows) Rows <span class="cov8" title="1">{
        return &amp;DelegateRows{
                rows: rows,
        }
}</span>

type DelegateRows struct {
        rows *sql.Rows
}

func (d *DelegateRows) Next() bool <span class="cov8" title="1">{
        return d.rows.Next()
}</span>

func (d *DelegateRows) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        return d.rows.Scan(dest...)
}</span>

type dbObject struct {
        //db is a transient pointer to database connection
        db SqlDB
}

//SetSession attachs a database connection to Card
func (d *dbObject) SetDB(db SqlDB) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return errors.New("NullSqlDBReferenceErr: Message='The db parameter is required'")
        }</span>
        <span class="cov8" title="1">d.db = db
        return nil</span>
}

//GetDB returns the attached database connection
func (d dbObject) GetDB() (SqlDB, error) <span class="cov0" title="0">{
        if d.db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("NotAttachedErr: Message='The sql connection is null'")
        }</span>
        <span class="cov0" title="0">return d.db, nil</span>
}

func (d *dbObject) Close() error <span class="cov8" title="1">{
        // return d.db.Close()
        return nil
}</span>

//QuerySupport adds query capability to the struct
type QuerySupport struct {
        dbObject
}

//QueryOne executes the sql query with the provided parameters and send the single result to the provided fetch function
func (q *QuerySupport) QueryOne(query string, fetchFunc func(persistence.Fetchable) error, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='NilReadQuery")
        }</span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='EmptyReadParameters")
        }</span>
        <span class="cov8" title="1">if fetchFunc == nil </span><span class="cov0" title="0">{
                return errors.New("identity.QuerySupport.QueryError: Messages='NilFetchFunction")
        }</span>
        <span class="cov8" title="1">row := q.db.QueryRow(query, params...)
        return fetchFunc(row)</span>
}

//Query executes the sql query with the provided parameters and send the results to the provided iter function
func (q *QuerySupport) Query(query string, iterFunc func(persistence.Iterable) error, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='EmptyCQLQuery']")
        }</span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='EmptyQueryParameters']")
        }</span>
        <span class="cov8" title="1">if iterFunc == nil </span><span class="cov0" title="0">{
                return errors.New("QueryError[Messages='NilIterFunc']")
        }</span>
        <span class="cov8" title="1">rows, err := q.db.Query(query, params...)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return iterFunc(rows)</span>
}

//ExecSupport adds cql exec capability to the struct
type ExecSupport struct {
        dbObject
}

//Exec exeutes the sql command with the provided parameters
func (i *ExecSupport) Exec(sql string, params ...interface{}) error <span class="cov8" title="1">{
        if strings.TrimSpace(sql) == "" </span><span class="cov0" title="0">{
                return errors.New("sql.ExecError[Messages='NilSQLQuery']")
        }</span>
        <span class="cov8" title="1">if params == nil || len(params) &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("ExecParametersLenInvalid[Messages='EmptyExecParameters']")
        }</span>
        <span class="cov8" title="1">result, err := i.db.Exec(sql, params...)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("sql.ExecutionFalied",
                        logger.String("SQL", sql),
                        logger.Struct("Parameters", params),
                )
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("SQLExecutedSuccessfully",
                logger.String("SQL", sql),
                logger.Struct("Parameters", params),
                logger.Struct("Result", result),
        )
        return nil</span>
}

//NewClient creates a new instance of the SQLClient
func NewClient(db SqlDB) *Client <span class="cov8" title="1">{
        client := new(Client)
        client.QuerySupport.SetDB(db)
        client.ExecSupport.SetDB(db)
        return client
}</span>

//Client adds full query and exec support fot the struct
type Client struct {
        QuerySupport
        ExecSupport
}

func (c *Client) Close() error <span class="cov8" title="1">{
        var errs []error
        if err := c.QuerySupport.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>
        <span class="cov8" title="1">if err := c.ExecSupport.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sql.Client.CloseErr msg='%v'", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
