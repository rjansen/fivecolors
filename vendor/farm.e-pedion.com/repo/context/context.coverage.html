
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">farm.e-pedion.com/repo/context/context.go (100.0%)</option>
				
				<option value="file1">farm.e-pedion.com/repo/context/fast/fasthttp.go (75.4%)</option>
				
				<option value="file2">farm.e-pedion.com/repo/context/http/http.go (75.7%)</option>
				
				<option value="file3">farm.e-pedion.com/repo/context/media/proto/data.pb.go (31.8%)</option>
				
				<option value="file4">farm.e-pedion.com/repo/context/media/proto/proto.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package context

import (
        "errors"
        "farm.e-pedion.com/repo/logger"
)

const (
        ContentTypeHeader   = "Content-Type"
        ContentLengthHeader = "Content-Length"
        AcceptHeader        = "Accept"
)

var (
        ErrInvalidContentType = errors.New("Invalid ContentType. Only: aplication/json, application/octet-stream are valid")
        ErrInvalidAccept      = errors.New("Invalid Accept. Only: aplication/json, application/octet-stream are valid")
)

//SetupAll calls all provided setup functions and return all raised errors
func SetupAll(setupFuncs ...SetupFunc) []error <span class="cov8" title="1">{
        var errs []error
        for i, v := range setupFuncs </span><span class="cov8" title="1">{
                if err := v(); err != nil </span><span class="cov8" title="1">{
                        logger.Warn("contex.SetupSilent",
                                logger.Int("index", i),
                                logger.Struct("func", v),
                                logger.Err(err),
                        )
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

//Setup calls the provided setup functions and return at the first raised error
func Setup(setupFuncs ...SetupFunc) error <span class="cov8" title="1">{
        for i, v := range setupFuncs </span><span class="cov8" title="1">{
                if err := v(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("contex.Setup",
                                logger.Int("index", i),
                                logger.Struct("func", v),
                                logger.Err(err),
                        )
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package fast

import (
        "bytes"
        "context"
        haki "farm.e-pedion.com/repo/context"
        "farm.e-pedion.com/repo/context/media/json"
        "farm.e-pedion.com/repo/context/media/proto"
        "farm.e-pedion.com/repo/logger"
        "github.com/valyala/fasthttp"
        "net/http"
        "time"
)

//SimpleHTTPHandler is a contract for fast http handlers
type SimpleHTTPHandler interface {
        HandleRequest(*fasthttp.RequestCtx)
}

//HTTPHandlerFunc is a function to handle fasthttp requrests
type HTTPHandlerFunc func(context.Context, *fasthttp.RequestCtx) error

//HandleRequest is the contract with HTTPHandler interface
func (h HTTPHandlerFunc) HandleRequest(c context.Context, fc *fasthttp.RequestCtx) error <span class="cov0" title="0">{
        return h(c, fc)
}</span>

//HTTPHandler is a contract for fast http handlers
type HTTPHandler interface {
        HandleRequest(context.Context, *fasthttp.RequestCtx) error
}

//Handler wraps a library handler func nto a fasthttp handler func
func Handler(handler HTTPHandlerFunc) fasthttp.RequestHandler <span class="cov8" title="1">{
        return func(ctx *fasthttp.RequestCtx) </span><span class="cov8" title="1">{
                c, cancel := context.WithCancel(context.Background())
                defer cancel()
                handler(c, ctx)
        }</span>
}

func errorHandle(handler HTTPHandlerFunc, c context.Context, fc *fasthttp.RequestCtx) error <span class="cov8" title="1">{
        if err := handler(c, fc); err != nil </span><span class="cov8" title="1">{
                fc.Error(err.Error(), fasthttp.StatusInternalServerError)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//ErrorHandler is a helper type to add exception control to other handlers
type ErrorHandler func(context.Context, *fasthttp.RequestCtx) error

//HandleRequest is the HTTPHandler contract
func (h ErrorHandler) HandleRequest(c context.Context, fc *fasthttp.RequestCtx) error <span class="cov0" title="0">{
        return errorHandle(HTTPHandlerFunc(h), c, fc)
}</span>

//Error wraps the provided HTTPHandlerFunc with exception control
func Error(handler HTTPHandlerFunc) HTTPHandlerFunc <span class="cov8" title="1">{
        return func(c context.Context, fc *fasthttp.RequestCtx) error </span><span class="cov8" title="1">{
                return errorHandle(handler, c, fc)
        }</span>
}

func logHandle(handler HTTPHandlerFunc, c context.Context, fc *fasthttp.RequestCtx) error <span class="cov8" title="1">{
        start := time.Now()
        logger.Info("contex.Request",
                logger.Int64("tid", int64(fc.ConnID())),
                logger.Int64("rid", int64(fc.ConnRequestNum())),
                logger.Bytes("method", fc.Method()),
                logger.Bytes("path", fc.Path()),
        )
        logger.Debug("context.Context",
                logger.Bool("ctxIsNil", fc == nil),
                logger.Bool("containerIsNil", c == nil),
        )
        c = context.WithValue(c, "log", logger.Get())
        var err error
        if err = handler(c, fc); err != nil </span><span class="cov8" title="1">{
                logger.Error("contex.LogHandler.Error",
                        logger.Int64("tid", int64(fc.ConnID())),
                        logger.Int64("rid", int64(fc.ConnRequestNum())),
                        logger.Bytes("method", fc.Method()),
                        logger.Bytes("path", fc.Path()),
                        logger.Err(err),
                )
        }</span>
        <span class="cov8" title="1">logger.Info("context.Response",
                logger.Int64("tid", int64(fc.ConnID())),
                logger.Int64("rid", int64(fc.ConnRequestNum())),
                logger.Bytes("method", fc.Method()),
                logger.Bytes("path", fc.Path()),
                logger.String("status", http.StatusText(fc.Response.StatusCode())),
                logger.Int("size", fc.Response.Header.ContentLength()),
                logger.Duration("requestTime", time.Since(start)),
        )
        return err</span>
}

//LogHandler is a helper type to add access logging control to other handlers
type LogHandler func(context.Context, *fasthttp.RequestCtx) error

//HandleRequest is the HTTPHandler contract
func (h LogHandler) HandleRequest(c context.Context, fc *fasthttp.RequestCtx) error <span class="cov0" title="0">{
        return logHandle(HTTPHandlerFunc(h), c, fc)
}</span>

//Log wraps the provided HTTPHandlerFunc with access logging control
func Log(handler HTTPHandlerFunc) HTTPHandlerFunc <span class="cov8" title="1">{
        return func(c context.Context, fc *fasthttp.RequestCtx) error </span><span class="cov8" title="1">{
                return logHandle(handler, c, fc)
        }</span>
}

//ReadByContentType reads data from context using the Content-Type header to define the media type
func ReadByContentType(ctx *fasthttp.RequestCtx, data interface{}) error <span class="cov8" title="1">{
        contentType := ctx.Request.Header.ContentType()
        switch </span>{
        <span class="cov8" title="1">case bytes.Contains(contentType, []byte(json.ContentType)):
                return ReadJSON(ctx, data)</span>
        <span class="cov0" title="0">case bytes.Contains(contentType, []byte(proto.ContentType)):
                return ReadProtoBuff(ctx, data)</span>
        <span class="cov0" title="0">default:
                return haki.ErrInvalidContentType</span>
        }
}

//WriteByAccept writes data to context using the Accept header to define the media type
func WriteByAccept(ctx *fasthttp.RequestCtx, status int, result interface{}) error <span class="cov8" title="1">{
        contentType := ctx.Request.Header.Peek(haki.AcceptHeader)
        switch </span>{
        <span class="cov8" title="1">case bytes.Contains(contentType, []byte(json.ContentType)):
                return JSON(ctx, status, result)</span>
        <span class="cov8" title="1">case bytes.Contains(contentType, []byte(proto.ContentType)):
                return ProtoBuff(ctx, status, result)</span>
        <span class="cov0" title="0">default:
                return haki.ErrInvalidAccept</span>
        }
}

//JSON writes the provided json media to the response
func JSON(ctx *fasthttp.RequestCtx, status int, result interface{}) error <span class="cov8" title="1">{
        jsonBytes, err := json.MarshalBytes(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ctx.SetBody(jsonBytes)
        ctx.SetContentType(json.ContentType)
        ctx.SetStatusCode(status)
        return nil</span>
}

//ReadJSON unmarshals from provided context a json media into data
func ReadJSON(ctx *fasthttp.RequestCtx, data interface{}) error <span class="cov8" title="1">{
        if err := json.UnmarshalBytes(ctx.PostBody(), data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//ProtoBuff writes the provided protocol buffer media to the response
func ProtoBuff(ctx *fasthttp.RequestCtx, status int, result interface{}) error <span class="cov8" title="1">{
        protoBytes, err := proto.MarshalBytes(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ctx.SetBody(protoBytes)
        ctx.SetContentType(proto.ContentType)
        ctx.SetStatusCode(status)
        return nil</span>
}

//ReadProtoBuff unmarshals from provided context a protocol buffer media into data
func ReadProtoBuff(ctx *fasthttp.RequestCtx, data interface{}) error <span class="cov0" title="0">{
        if err := proto.UnmarshalBytes(ctx.PostBody(), data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//Status writes the provided status to the response
func Status(ctx *fasthttp.RequestCtx, status int) error <span class="cov8" title="1">{
        ctx.SetStatusCode(status)
        return nil
}</span>

//Err writes the provided  error to the response
func Err(ctx *fasthttp.RequestCtx, err error) error <span class="cov8" title="1">{
        //w.WriteHeader(http.StatusInternalServerError)
        ctx.Error(err.Error(), fasthttp.StatusInternalServerError)
        return err
}</span>

//BaseHandler is a struct to add response helper function to other handlers
type BaseHandler struct {
}

//JSON writes a json media to response
func (h BaseHandler) JSON(ctx *fasthttp.RequestCtx, status int, result interface{}) error <span class="cov0" title="0">{
        return JSON(ctx, status, result)
}</span>

//Status writes the provided status to response
func (h BaseHandler) Status(ctx *fasthttp.RequestCtx, status int) error <span class="cov0" title="0">{
        return Status(ctx, status)
}</span>

//Err writes a error to response
func (h BaseHandler) Err(ctx *fasthttp.RequestCtx, err error) error <span class="cov0" title="0">{
        return Err(ctx, err)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "context"
        haki "farm.e-pedion.com/repo/context"
        "farm.e-pedion.com/repo/context/media/json"
        "farm.e-pedion.com/repo/logger"
        "github.com/satori/go.uuid"
        "net/http"
        "strings"
        "time"
)

//ResponseWriter is a wrapper function to store status and body length of the request
type ResponseWriter interface {
        http.ResponseWriter
        http.Flusher
        // Status returns the status code of the response or 200 if the response has
        // not been written (as this is the default response code in net/http)
        Status() int
        // Written returns whether or not the ResponseWriter has been written.
        Written() bool
        // Size returns the size of the response body.
        Size() int
}

// NewResponseWriter creates a ResponseWriter that wraps an http.ResponseWriter
func NewResponseWriter(w http.ResponseWriter) ResponseWriter <span class="cov8" title="1">{
        return &amp;responseWriter{
                ResponseWriter: w,
        }
}</span></span></span>

type responseWriter struct {
        http.ResponseWriter
        status int
        size   int
}

func (w *responseWriter) WriteHeader(s int) <span class="cov8" title="1">{
        w.status = s
        w.ResponseWriter.WriteHeader(s)
}</span></span></span>

func (w *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !w.Written() </span></span></span><span class="cov0" title="0">{
                // The status will be 200 if WriteHeader has not been called yet
                w.WriteHeader(http.StatusOK)
        }</span></span></span>
        <span class="cov8" title="1">size, err := w.ResponseWriter.Write(b)
        w.size += size
        return size, err</span></span></span>
}

func (w *responseWriter) Status() int <span class="cov8" title="1">{
        return w.status
}</span></span></span>

func (w *responseWriter) Size() int <span class="cov8" title="1">{
        return w.size
}</span></span></span>

func (w *responseWriter) Written() bool <span class="cov8" title="1">{
        return w.status != 0
}</span></span></span>

func (w *responseWriter) Flush() <span class="cov0" title="0">{
        flusher, ok := w.ResponseWriter.(http.Flusher)
        if ok </span></span></span><span class="cov0" title="0">{
                if !w.Written() </span></span></span><span class="cov0" title="0">{
                        // The status will be 200 if WriteHeader has not been called yet
                        w.WriteHeader(http.StatusOK)
                }</span></span></span>
                <span class="cov0" title="0">flusher.Flush()</span></span></span>
        }
}

//SimpleHTTPHandler is a contract for fast http handlers
type SimpleHTTPHandler interface {
        ServeHTTP(http.ResponseWriter, *http.Request)
}

//HTTPHandlerFunc is a function to handle fasthttp requrests
type HTTPHandlerFunc func(http.ResponseWriter, *http.Request) error

//HandleRequest is the contract with HTTPHandler interface
func (h HTTPHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        return h(w, r)
}</span></span></span>

//HTTPHandler is a contract for fast http handlers
type HTTPHandler interface {
        ServeHTTP(http.ResponseWriter, *http.Request) error
}

//Handler wraps a library handler func nto a http handler func
func Handler(handler HTTPHandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, h *http.Request) </span></span></span><span class="cov8" title="1">{
                handler(w, h)
        }</span></span></span>
}

func errorHandle(handler HTTPHandlerFunc, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        if err := handler(w, r); err != nil </span></span></span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return err
        }</span></span></span>
        <span class="cov8" title="1">return nil</span></span></span>
}

//Error wraps the provided HTTPHandlerFunc with exception control
func Error(handler HTTPHandlerFunc) HTTPHandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) error </span></span></span><span class="cov8" title="1">{
                return errorHandle(handler, w, r)
        }</span></span></span>
}

type ErrorHandler func(http.ResponseWriter, *http.Request) error

func (h ErrorHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
}</span></span></span>

func logHandle(handler HTTPHandlerFunc, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        tid := uuid.NewV4().String()
        r = r.WithContext(context.WithValue(r.Context(), "tid", tid))
        start := time.Now()
        logger.Info("contex.Request",
                logger.String("tid", tid),
                logger.String("method", r.Method),
                logger.String("path", r.URL.Path),
        )
        logger.Debug("context.Context",
                logger.Bool("ctxIsNil", r.Context() == nil),
        )
        r = r.WithContext(context.WithValue(r.Context(), "log", logger.Get()))
        rw := NewResponseWriter(w)
        var err error
        if err = handler(rw, r); err != nil </span></span></span><span class="cov8" title="1">{
                logger.Error("contex.LogHandler.Error",
                        logger.String("tid", tid),
                        logger.String("method", r.Method),
                        logger.String("path", r.URL.Path),
                        logger.Err(err),
                )
        }</span></span></span>
        <span class="cov8" title="1">response := rw.(ResponseWriter)
        logger.Info("context.Response",
                logger.String("tid", tid),
                logger.String("method", r.Method),
                logger.String("path", r.URL.Path),
                logger.String("status", http.StatusText(response.Status())),
                logger.Int("size", response.Size()),
                logger.Duration("requestTime", time.Since(start)),
        )
        return err</span></span></span>
}

//Log wraps the provided HTTPHandlerFunc with access logging control
func Log(handler HTTPHandlerFunc) HTTPHandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) error </span></span></span><span class="cov8" title="1">{
                return logHandle(handler, w, r)
        }</span></span></span>
}

type LogHandler func(http.ResponseWriter, *http.Request) error

func (h LogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logHandle(HTTPHandlerFunc(h), w, r)
}</span></span></span>

//ReadByContentType reads data from context using the Content-Type header to define the media type
func ReadByContentType(r *http.Request, data interface{}) error <span class="cov8" title="1">{
        contentType := r.Header.Get(haki.ContentTypeHeader)
        switch </span></span></span>{
        <span class="cov8" title="1">case strings.Contains(contentType, json.ContentType):
                return ReadJSON(r, data)</span></span></span>
        // case strings.Contains(contentType, proto.ContentType):
        //         return ReadProtoBuff(r, data)
        <span class="cov0" title="0">default:
                return haki.ErrInvalidContentType</span></span></span>
        }
}

//WriteByAccept writes data to context using the Accept header to define the media type
func WriteByAccept(w http.ResponseWriter, r *http.Request, status int, result interface{}) error <span class="cov8" title="1">{
        contentType := r.Header.Get(haki.AcceptHeader)
        switch </span></span></span>{
        <span class="cov8" title="1">case strings.Contains(contentType, json.ContentType):
                return JSON(w, status, result)</span></span></span>
        // case bytes.Contains(contentType, []byte(proto.ContentType)):
        //         return ProtoBuff(ctx, status, result)
        <span class="cov0" title="0">default:
                return haki.ErrInvalidAccept</span></span></span>
        }
}

//ReadJSON unmarshals from provided context a json media into data
func ReadJSON(r *http.Request, data interface{}) error <span class="cov8" title="1">{
        if err := json.Unmarshal(r.Body, data); err != nil </span></span></span><span class="cov0" title="0">{
                return err
        }</span></span></span>
        <span class="cov8" title="1">return nil</span></span></span>
}

func Bytes(w http.ResponseWriter, status int, result []byte) error <span class="cov8" title="1">{
        _, err := w.Write(result)
        if err != nil </span></span></span><span class="cov0" title="0">{
                return err
        }</span></span></span>
        <span class="cov8" title="1">w.Header().Set(haki.ContentTypeHeader, "application/octet-stream")
        w.WriteHeader(status)
        return nil</span></span></span>
}

func JSON(w http.ResponseWriter, status int, result interface{}) error <span class="cov8" title="1">{
        if err := json.Marshal(w, result); err != nil </span></span></span><span class="cov0" title="0">{
                return err
        }</span></span></span>
        <span class="cov8" title="1">w.Header().Set(haki.ContentTypeHeader, json.ContentType)
        w.WriteHeader(status)
        return nil</span></span></span>
}

func Status(w http.ResponseWriter, status int) error <span class="cov8" title="1">{
        w.WriteHeader(status)
        return nil
}</span></span></span>

func Err(w http.ResponseWriter, err error) error <span class="cov8" title="1">{
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return err
}</span></span></span>

type BaseHandler struct {
}

func (h BaseHandler) JSON(w http.ResponseWriter, status int, result interface{}) error <span class="cov0" title="0">{
        return JSON(w, status, result)
}</span></span></span>

func (h BaseHandler) Status(w http.ResponseWriter, status int) error <span class="cov0" title="0">{
        return Status(w, status)
}</span></span></span>

func (h BaseHandler) Err(w http.ResponseWriter, err error) error <span class="cov0" title="0">{
        return Err(w, err)
}</span></span></span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go.
// source: media/proto/data.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
        media/proto/data.proto

It has these top-level messages:
        Store
        StoreStream
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Store_DataType int32

const (
        Store_MOBILE Store_DataType = 0
        Store_HOME   Store_DataType = 1
        Store_WORK   Store_DataType = 2
)

var Store_DataType_name = map[int32]string{
        0: "MOBILE",
        1: "HOME",
        2: "WORK",
}
var Store_DataType_value = map[string]int32{
        "MOBILE": 0,
        "HOME":   1,
        "WORK":   2,
}

func (x Store_DataType) String() string <span class="cov0" title="0">{
        return proto1.EnumName(Store_DataType_name, int32(x))
}</span>
func (Store_DataType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0, 0} }</span>

type Store struct {
        Id   int32         `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
        Name string        `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
        Data []*Store_Data `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
}

func (m *Store) Reset()                    <span class="cov8" title="1">{ *m = Store{} }</span>
func (m *Store) String() string            <span class="cov8" title="1">{ return proto1.CompactTextString(m) }</span>
func (*Store) ProtoMessage()               <span class="cov0" title="0">{}</span>
func (*Store) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0} }</span>

func (m *Store) GetData() []*Store_Data <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Store_Data struct {
        Id     int32          `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
        Name   string         `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
        Email  string         `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
        Number string         `protobuf:"bytes,4,opt,name=number" json:"number,omitempty"`
        Type   Store_DataType `protobuf:"varint,5,opt,name=type,enum=proto.Store_DataType" json:"type,omitempty"`
}

func (m *Store_Data) Reset()                    <span class="cov0" title="0">{ *m = Store_Data{} }</span>
func (m *Store_Data) String() string            <span class="cov0" title="0">{ return proto1.CompactTextString(m) }</span>
func (*Store_Data) ProtoMessage()               <span class="cov0" title="0">{}</span>
func (*Store_Data) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0, 0} }</span>

type StoreStream struct {
        Stores []*Store `protobuf:"bytes,1,rep,name=stores" json:"stores,omitempty"`
}

func (m *StoreStream) Reset()                    <span class="cov0" title="0">{ *m = StoreStream{} }</span>
func (m *StoreStream) String() string            <span class="cov0" title="0">{ return proto1.CompactTextString(m) }</span>
func (*StoreStream) ProtoMessage()               <span class="cov0" title="0">{}</span>
func (*StoreStream) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{1} }</span>

func (m *StoreStream) GetStores() []*Store <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Stores
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto1.RegisterType((*Store)(nil), "proto.Store")
        proto1.RegisterType((*Store_Data)(nil), "proto.Store.Data")
        proto1.RegisterType((*StoreStream)(nil), "proto.StoreStream")
        proto1.RegisterEnum("proto.Store_DataType", Store_DataType_name, Store_DataType_value)
}</span>

func init() <span class="cov8" title="1">{ proto1.RegisterFile("media/proto/data.proto", fileDescriptor0) }</span>

var fileDescriptor0 = []byte{
        // 248 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x8f, 0x41, 0x4b, 0xc3, 0x30,
        0x14, 0xc7, 0x4d, 0x9a, 0x94, 0xf9, 0x26, 0xa3, 0x3e, 0x74, 0x04, 0x4f, 0xa5, 0x28, 0x54, 0x0f,
        0x1d, 0x6c, 0xdf, 0x40, 0x1c, 0x28, 0x3a, 0x0a, 0x99, 0xe0, 0x39, 0xa3, 0xef, 0x50, 0x30, 0x6b,
        0xe9, 0xe2, 0x61, 0x67, 0xfd, 0xe0, 0x92, 0xb7, 0x09, 0x82, 0x17, 0x4f, 0xf9, 0xff, 0x7f, 0x2f,
        0xf9, 0x25, 0x81, 0xa9, 0xa7, 0xa6, 0x75, 0xb3, 0x7e, 0xe8, 0x42, 0x37, 0x6b, 0x5c, 0x70, 0x15,
        0x47, 0xd4, 0xbc, 0x14, 0x5f, 0x12, 0xf4, 0x3a, 0x74, 0x03, 0xe1, 0x04, 0x64, 0xdb, 0x18, 0x91,
        0x8b, 0x52, 0x5b, 0xd9, 0x36, 0x88, 0xa0, 0xb6, 0xce, 0x93, 0x91, 0xb9, 0x28, 0x4f, 0x2d, 0x67,
        0xbc, 0x01, 0x15, 0x15, 0x26, 0xc9, 0x93, 0x72, 0x3c, 0x3f, 0x3f, 0xa8, 0x2a, 0x3e, 0x5f, 0x3d,
        0xb8, 0xe0, 0x2c, 0x8f, 0xaf, 0x3e, 0x05, 0xa8, 0x58, 0xff, 0xe5, 0xbc, 0x00, 0x4d, 0xde, 0xb5,
        0xef, 0x26, 0x61, 0x78, 0x28, 0x38, 0x85, 0x74, 0xfb, 0xe1, 0x37, 0x34, 0x18, 0xc5, 0xf8, 0xd8,
        0xf0, 0x16, 0x54, 0xd8, 0xf7, 0x64, 0x74, 0x2e, 0xca, 0xc9, 0xfc, 0xf2, 0xcf, 0x0b, 0x5e, 0xf7,
        0x3d, 0x59, 0xde, 0x52, 0xdc, 0xc1, 0xe8, 0x87, 0x20, 0x40, 0xba, 0xaa, 0xef, 0x9f, 0x5e, 0x96,
        0xd9, 0x09, 0x8e, 0x40, 0x3d, 0xd6, 0xab, 0x65, 0x26, 0x62, 0x7a, 0xab, 0xed, 0x73, 0x26, 0x8b,
        0x05, 0x8c, 0xd9, 0xb1, 0x0e, 0x03, 0x39, 0x8f, 0xd7, 0x90, 0xee, 0x62, 0xdd, 0x19, 0xc1, 0x3f,
        0x3d, 0xfb, 0x7d, 0x8f, 0x3d, 0xce, 0x36, 0x29, 0xc3, 0xc5, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xdd, 0x91, 0xcc, 0x3f, 0x63, 0x01, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package proto

import (
        "bytes"
        "errors"
        "farm.e-pedion.com/repo/logger"
        "github.com/golang/protobuf/proto"
        "io"
)

var (
        //ErrInvalidProtoMessage is returned when a invalid message is provided
        ErrInvalidProtoMessage = errors.New("Invalid proto message value")
        //ErrEmptyInput is returned when a empty input is provided
        ErrEmptyInput = errors.New("The provided input (reader, []bytes) is empty")
        //ContentType is a constant to hold the protocol buffer content type value
        ContentType = "application/octet-stream"
)

func protoMessage(val interface{}) (proto.Message, error) <span class="cov8" title="1">{
        msg, ok := val.(proto.Message)
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrInvalidProtoMessage
        }</span>
        <span class="cov8" title="1">return msg, nil</span>
}

//Marshal writes a json representation of the struct instance
func Marshal(w io.Writer, data interface{}) error <span class="cov8" title="1">{
        dataBytes, err := MarshalBytes(data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">buf := bytes.NewBuffer(dataBytes)
        _, err = buf.WriteTo(w)
        return err</span>
}

//Unmarshal reads a json representation into the struct instance
func Unmarshal(r io.Reader, result interface{}) error <span class="cov8" title="1">{
        var buf bytes.Buffer
        if reads, err := buf.ReadFrom(r); err != nil </span><span class="cov8" title="1">{
                return err
        }</span><span class="cov8" title="1"> else if reads &lt;= 0 </span><span class="cov8" title="1">{
                return ErrEmptyInput
        }</span>
        <span class="cov8" title="1">return UnmarshalBytes(buf.Bytes(), result)</span>
}

//MarshalBytes writes a json representation of the struct instance
func MarshalBytes(data interface{}) ([]byte, error) <span class="cov8" title="1">{
        msg, err := protoMessage(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">protoBytes, err := proto.Marshal(msg)
        logger.Debug("proto.MarshalBytes",
                logger.Int("len", len(protoBytes)),
                logger.Err(err),
        )
        return protoBytes, err</span>
}

//UnmarshalBytes reads a json representation into the struct instance
func UnmarshalBytes(raw []byte, result interface{}) error <span class="cov8" title="1">{
        msg, err := protoMessage(result)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = proto.Unmarshal(raw, msg)
        logger.Debug("proto.UnmarshalBytes",
                logger.Bool("nilResult", result == nil),
                logger.Err(err),
        )
        return err</span>
}

//Media is a struct to helps writes and reads of a json representation
type Media struct {
}

//Marshal writes a json representation of the struct instance
func (Media) Marshal(writer io.Writer, val interface{}) error <span class="cov0" title="0">{
        return Marshal(writer, val)
}</span>

//Unmarshal reads a json representation into the struct instance
func (Media) Unmarshal(reader io.Reader, ref interface{}) error <span class="cov0" title="0">{
        return Unmarshal(reader, ref)
}</span>

//MarshalBytes writes a json representation of the struct instance
func (Media) MarshalBytes(val interface{}) ([]byte, error) <span class="cov0" title="0">{
        return MarshalBytes(val)
}</span>

//UnmarshalBytes reads a json representation into the struct instance
func (Media) UnmarshalBytes(raw []byte, ref interface{}) error <span class="cov0" title="0">{
        return UnmarshalBytes(raw, ref)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
